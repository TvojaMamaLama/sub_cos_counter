name: Deploy to Production

on:
  push:
    branches: [ main, master ]
  pull_request:
    branches: [ main, master ]
    types: [ closed ]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v4
    
    - name: Set up Go
      uses: actions/setup-go@v4
      with:
        go-version: '1.24'
    
    - name: Cache Go modules
      uses: actions/cache@v3
      with:
        path: ~/go/pkg/mod
        key: ${{ runner.os }}-go-${{ hashFiles('**/go.sum') }}
        restore-keys: |
          ${{ runner.os }}-go-
    
    - name: Download dependencies
      run: go mod download
    
    - name: Run tests
      run: go test ./...
    
    - name: Build application
      run: go build -v ./cmd/bot

  deploy:
    needs: test
    runs-on: ubuntu-latest
    if: github.event_name == 'push' || (github.event_name == 'pull_request' && github.event.pull_request.merged == true)
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Setup SSH
      run: |
        mkdir -p ~/.ssh
        echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
        chmod 600 ~/.ssh/id_rsa
        ssh-keyscan -H ${{ secrets.SERVER_HOST }} >> ~/.ssh/known_hosts
    
    - name: Create deployment archive
      run: |
        tar -czf /tmp/deployment.tar.gz \
          --exclude='.git' \
          --exclude='*.tar.gz' \
          --exclude='logs' \
          --exclude='.env' \
          --exclude='node_modules' \
          --exclude='.github' \
          --exclude='*.log' \
          --exclude='backups' \
          -C . .
    
    - name: Copy files to server
      run: |
        scp -o StrictHostKeyChecking=no /tmp/deployment.tar.gz ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }}:/tmp/
    
    - name: Deploy on server
      run: |
        ssh -o StrictHostKeyChecking=no ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} << 'EOF'
          set -e
          
          # Variables
          APP_DIR="/opt/subscription-bot"
          BACKUP_DIR="/opt/subscription-bot-backup-$(date +%Y%m%d-%H%M%S)"
          
          # Create app directory if it doesn't exist
          mkdir -p $APP_DIR
          mkdir -p $(dirname $BACKUP_DIR)
          
          # Backup current deployment if it exists
          if [ -d "$APP_DIR" ] && [ "$(ls -A $APP_DIR)" ]; then
            echo "Creating backup..."
            cp -r $APP_DIR $BACKUP_DIR
          fi
          
          # Extract new deployment
          cd $APP_DIR
          rm -rf * .github .gitignore || true
          tar -xzf /tmp/deployment.tar.gz -C .
          chown -R root:root .
          
          # Create production environment file
          echo "Creating .env file with secrets..."
          cat > .env << EOF
# Production Environment Variables - Generated by GitHub Actions
TELEGRAM_BOT_TOKEN=${{ secrets.TELEGRAM_BOT_TOKEN }}
TELEGRAM_ALLOWED_USER=${{ secrets.TELEGRAM_ALLOWED_USER }}

# Database settings
DATABASE_NAME=sub_cos_counter
DATABASE_USER=postgres
DATABASE_PASSWORD=${{ secrets.DATABASE_PASSWORD }}
DATABASE_HOST=postgres
DATABASE_PORT=5432

# Application settings
APP_NAME=Subscription Tracker Bot
APP_VERSION=1.0.0
APP_ENVIRONMENT=production
APP_DEBUG=false

# Logging settings
LOGGING_LEVEL=info
LOGGING_FORMAT=json
LOGGING_OUTPUT=stdout

# Connection pool settings
DATABASE_MAX_CONNECTIONS=25
DATABASE_MAX_IDLE_TIME=15
DATABASE_CONN_MAX_LIFETIME=60
EOF
          
          # Show that .env was created (without showing secrets)
          echo ".env file created with $(wc -l < .env) lines"
          echo "Environment variables set:"
          grep -E "^[A-Z_]+=.*" .env | cut -d'=' -f1 | sort
          
          # Install Docker and Docker Compose via apt (simple!)
          echo "Installing Docker and Docker Compose via apt..."
          apt-get update
          apt-get install -y docker.io docker-compose
          systemctl start docker
          systemctl enable docker
          
          # Verify installations
          echo "Docker version:"
          docker --version
          
          # Use simple docker-compose command
          echo "Docker Compose version:"
          docker-compose --version
          DOCKER_COMPOSE="docker-compose"
          
          # Verify .env file exists and has content
          if [ -f .env ]; then
            echo "✅ .env file exists"
            echo "TELEGRAM_BOT_TOKEN is set: $(grep -q "TELEGRAM_BOT_TOKEN=" .env && echo "YES" || echo "NO")"
          else
            echo "❌ .env file missing!"
            exit 1
          fi
          
          # Stop existing containers
          $DOCKER_COMPOSE -f deployment/docker/docker-compose.yml --env-file .env down || true
          
          # Pull latest images and rebuild
          $DOCKER_COMPOSE -f deployment/docker/docker-compose.yml --env-file .env build --no-cache
          
          # Start services
          $DOCKER_COMPOSE -f deployment/docker/docker-compose.yml --env-file .env up -d
          
          # Wait for database to be ready
          echo "Waiting for database..."
          sleep 10
          
          # Check if services are running
          echo "Checking service status..."
          $DOCKER_COMPOSE -f deployment/docker/docker-compose.yml --env-file .env ps
          
          # Show logs
          echo "Recent logs:"
          $DOCKER_COMPOSE -f deployment/docker/docker-compose.yml --env-file .env logs --tail=20
          
          # Cleanup
          rm -f /tmp/deployment.tar.gz
          
          echo "Waiting for services to start..."
          sleep 15
          
          # Verify deployment in same session
          echo "=== Deployment Verification ==="
          
          # Check if containers are running
          if $DOCKER_COMPOSE -f deployment/docker/docker-compose.yml --env-file .env ps | grep -q "Up"; then
            echo "✅ Deployment verification successful - containers are running"
            
            # Show container status
            echo "Container status:"
            $DOCKER_COMPOSE -f deployment/docker/docker-compose.yml --env-file .env ps
            
            # Show recent logs
            echo "Recent bot logs:"
            $DOCKER_COMPOSE -f deployment/docker/docker-compose.yml --env-file .env logs --tail=10 bot
          else
            echo "❌ Deployment verification failed - containers are not running"
            echo "Container status:"
            $DOCKER_COMPOSE -f deployment/docker/docker-compose.yml --env-file .env ps
            echo "Error logs:"
            $DOCKER_COMPOSE -f deployment/docker/docker-compose.yml --env-file .env logs --tail=20
            exit 1
          fi
          
          echo "Deployment completed successfully!"
        EOF

  notify:
    needs: [test, deploy]
    runs-on: ubuntu-latest
    if: always()
    steps:
    - name: Notify deployment status
      run: |
        if [ "${{ needs.deploy.result }}" == "success" ]; then
          echo "🚀 Deployment successful!"
        else
          echo "❌ Deployment failed!"
        fi