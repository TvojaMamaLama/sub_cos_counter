name: Deploy to Production

on:
  push:
    branches: [ main, master ]
  pull_request:
    branches: [ main, master ]
    types: [ closed ]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v4
    
    - name: Set up Go
      uses: actions/setup-go@v4
      with:
        go-version: '1.24'
    
    - name: Cache Go modules
      uses: actions/cache@v3
      with:
        path: ~/go/pkg/mod
        key: ${{ runner.os }}-go-${{ hashFiles('**/go.sum') }}
        restore-keys: |
          ${{ runner.os }}-go-
    
    - name: Download dependencies
      run: go mod download
    
    - name: Run tests
      run: go test ./...
    
    - name: Build application
      run: go build -v ./cmd/bot

  deploy:
    needs: test
    runs-on: ubuntu-latest
    if: github.event_name == 'push' || (github.event_name == 'pull_request' && github.event.pull_request.merged == true)
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Setup SSH
      run: |
        mkdir -p ~/.ssh
        echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
        chmod 600 ~/.ssh/id_rsa
        ssh-keyscan -H ${{ secrets.SERVER_HOST }} >> ~/.ssh/known_hosts
    
    - name: Create deployment archive
      run: |
        tar -czf /tmp/deployment.tar.gz \
          --exclude='.git' \
          --exclude='*.tar.gz' \
          --exclude='logs' \
          --exclude='.env' \
          --exclude='node_modules' \
          --exclude='.github' \
          --exclude='*.log' \
          --exclude='backups' \
          -C . .
    
    - name: Copy files to server
      run: |
        scp -o StrictHostKeyChecking=no /tmp/deployment.tar.gz ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }}:/tmp/
    
    - name: Deploy on server
      run: |
        ssh -o StrictHostKeyChecking=no ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} << 'EOF'
          set -e
          
          # Variables
          APP_DIR="/opt/subscription-bot"
          BACKUP_DIR="/opt/subscription-bot-backup-$(date +%Y%m%d-%H%M%S)"
          
          # Create app directory if it doesn't exist
          mkdir -p $APP_DIR
          mkdir -p $(dirname $BACKUP_DIR)
          
          # Backup current deployment if it exists
          if [ -d "$APP_DIR" ] && [ "$(ls -A $APP_DIR)" ]; then
            echo "Creating backup..."
            cp -r $APP_DIR $BACKUP_DIR
          fi
          
          # Extract new deployment
          cd $APP_DIR
          rm -rf * .github .gitignore || true
          tar -xzf /tmp/deployment.tar.gz -C .
          chown -R root:root .
          
          # Create production environment file
          tee .env > /dev/null << 'ENVEOF'
          # Production Environment Variables
          TELEGRAM_BOT_TOKEN=${{ secrets.TELEGRAM_BOT_TOKEN }}
          TELEGRAM_ALLOWED_USER=${{ secrets.TELEGRAM_ALLOWED_USER }}
          
          # Database settings
          DATABASE_NAME=sub_cos_counter
          DATABASE_USER=postgres
          DATABASE_PASSWORD=${{ secrets.DATABASE_PASSWORD }}
          DATABASE_HOST=postgres
          DATABASE_PORT=5432
          
          # Application settings
          APP_NAME=Subscription Tracker Bot
          APP_VERSION=1.0.0
          APP_ENVIRONMENT=production
          APP_DEBUG=false
          
          # Logging settings
          LOGGING_LEVEL=info
          LOGGING_FORMAT=json
          LOGGING_OUTPUT=stdout
          
          # Connection pool settings
          DATABASE_MAX_CONNECTIONS=25
          DATABASE_MAX_IDLE_TIME=15
          DATABASE_CONN_MAX_LIFETIME=60
          ENVEOF
          
          # Install Docker and Docker Compose if not installed
          if ! command -v docker &> /dev/null; then
            echo "Installing Docker..."
            apt-get update
            apt-get install -y ca-certificates curl
            curl -fsSL https://get.docker.com -o get-docker.sh
            sh get-docker.sh
            systemctl start docker
            systemctl enable docker
            usermod -aG docker root
          fi
          
          if ! command -v docker-compose &> /dev/null && [ ! -f /usr/local/bin/docker-compose ]; then
            echo "Installing Docker Compose..."
            curl -L "https://github.com/docker/compose/releases/latest/download/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
            chmod +x /usr/local/bin/docker-compose
            # Create symlink for easier access
            ln -sf /usr/local/bin/docker-compose /usr/bin/docker-compose
            # Update PATH for current session
            export PATH="/usr/local/bin:$PATH"
          fi
          
          # Verify installations
          echo "Docker version:"
          docker --version
          echo "Docker Compose version:"
          /usr/local/bin/docker-compose --version
          
          # Set docker-compose path
          DOCKER_COMPOSE="/usr/local/bin/docker-compose"
          
          # Stop existing containers
          $DOCKER_COMPOSE -f deployment/docker/docker-compose.yml --env-file .env down || true
          
          # Pull latest images and rebuild
          $DOCKER_COMPOSE -f deployment/docker/docker-compose.yml --env-file .env build --no-cache
          
          # Start services
          $DOCKER_COMPOSE -f deployment/docker/docker-compose.yml --env-file .env up -d
          
          # Wait for database to be ready
          echo "Waiting for database..."
          sleep 10
          
          # Check if services are running
          echo "Checking service status..."
          $DOCKER_COMPOSE -f deployment/docker/docker-compose.yml ps
          
          # Show logs
          echo "Recent logs:"
          $DOCKER_COMPOSE -f deployment/docker/docker-compose.yml logs --tail=20
          
          # Cleanup
          rm -f /tmp/deployment.tar.gz
          
          echo "Deployment completed successfully!"
        EOF
    
    - name: Verify deployment
      run: |
        ssh -o StrictHostKeyChecking=no ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} << 'EOF'
          cd /opt/subscription-bot
          
          # Set docker-compose path
          DOCKER_COMPOSE="/usr/local/bin/docker-compose"
          
          # Check if containers are running
          if $DOCKER_COMPOSE -f deployment/docker/docker-compose.yml ps | grep -q "Up"; then
            echo "âœ… Deployment verification successful - containers are running"
            
            # Show container status
            echo "Container status:"
            $DOCKER_COMPOSE -f deployment/docker/docker-compose.yml ps
            
            # Show recent logs
            echo "Recent bot logs:"
            $DOCKER_COMPOSE -f deployment/docker/docker-compose.yml logs --tail=10 bot
          else
            echo "âŒ Deployment verification failed - containers are not running"
            echo "Container status:"
            $DOCKER_COMPOSE -f deployment/docker/docker-compose.yml ps
            echo "Error logs:"
            $DOCKER_COMPOSE -f deployment/docker/docker-compose.yml logs --tail=20
            exit 1
          fi
        EOF

  notify:
    needs: [test, deploy]
    runs-on: ubuntu-latest
    if: always()
    steps:
    - name: Notify deployment status
      run: |
        if [ "${{ needs.deploy.result }}" == "success" ]; then
          echo "ðŸš€ Deployment successful!"
        else
          echo "âŒ Deployment failed!"
        fi